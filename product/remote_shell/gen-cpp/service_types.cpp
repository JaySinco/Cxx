/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace cxx { namespace service {


ComputerInfo::~ComputerInfo() throw() {
}


void ComputerInfo::__set_osName(const std::string& val) {
  this->osName = val;
}

void ComputerInfo::__set_userName(const std::string& val) {
  this->userName = val;
}
std::ostream& operator<<(std::ostream& out, const ComputerInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ComputerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->osName);
          this->__isset.osName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          this->__isset.userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ComputerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ComputerInfo");

  xfer += oprot->writeFieldBegin("osName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->osName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->userName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ComputerInfo &a, ComputerInfo &b) {
  using ::std::swap;
  swap(a.osName, b.osName);
  swap(a.userName, b.userName);
  swap(a.__isset, b.__isset);
}

ComputerInfo::ComputerInfo(const ComputerInfo& other0) {
  osName = other0.osName;
  userName = other0.userName;
  __isset = other0.__isset;
}
ComputerInfo& ComputerInfo::operator=(const ComputerInfo& other1) {
  osName = other1.osName;
  userName = other1.userName;
  __isset = other1.__isset;
  return *this;
}
void ComputerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ComputerInfo(";
  out << "osName=" << to_string(osName);
  out << ", " << "userName=" << to_string(userName);
  out << ")";
}


CpuInfo::~CpuInfo() throw() {
}


void CpuInfo::__set_rate(const double val) {
  this->rate = val;
}
std::ostream& operator<<(std::ostream& out, const CpuInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CpuInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->rate);
          this->__isset.rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CpuInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CpuInfo");

  xfer += oprot->writeFieldBegin("rate", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->rate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CpuInfo &a, CpuInfo &b) {
  using ::std::swap;
  swap(a.rate, b.rate);
  swap(a.__isset, b.__isset);
}

CpuInfo::CpuInfo(const CpuInfo& other2) {
  rate = other2.rate;
  __isset = other2.__isset;
}
CpuInfo& CpuInfo::operator=(const CpuInfo& other3) {
  rate = other3.rate;
  __isset = other3.__isset;
  return *this;
}
void CpuInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CpuInfo(";
  out << "rate=" << to_string(rate);
  out << ")";
}


MemoryInfo::~MemoryInfo() throw() {
}


void MemoryInfo::__set_total(const double val) {
  this->total = val;
}

void MemoryInfo::__set_used(const double val) {
  this->used = val;
}
std::ostream& operator<<(std::ostream& out, const MemoryInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MemoryInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->used);
          this->__isset.used = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MemoryInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MemoryInfo");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("used", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->used);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MemoryInfo &a, MemoryInfo &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.used, b.used);
  swap(a.__isset, b.__isset);
}

MemoryInfo::MemoryInfo(const MemoryInfo& other4) {
  total = other4.total;
  used = other4.used;
  __isset = other4.__isset;
}
MemoryInfo& MemoryInfo::operator=(const MemoryInfo& other5) {
  total = other5.total;
  used = other5.used;
  __isset = other5.__isset;
  return *this;
}
void MemoryInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MemoryInfo(";
  out << "total=" << to_string(total);
  out << ", " << "used=" << to_string(used);
  out << ")";
}


DiskInfo::~DiskInfo() throw() {
}


void DiskInfo::__set_total(const double val) {
  this->total = val;
}

void DiskInfo::__set_free(const double val) {
  this->free = val;
}

void DiskInfo::__set_readSpeed(const double val) {
  this->readSpeed = val;
}

void DiskInfo::__set_writeSpeed(const double val) {
  this->writeSpeed = val;
}
std::ostream& operator<<(std::ostream& out, const DiskInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DiskInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->free);
          this->__isset.free = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->readSpeed);
          this->__isset.readSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->writeSpeed);
          this->__isset.writeSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DiskInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DiskInfo");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("free", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->free);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readSpeed", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->readSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeSpeed", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->writeSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DiskInfo &a, DiskInfo &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.free, b.free);
  swap(a.readSpeed, b.readSpeed);
  swap(a.writeSpeed, b.writeSpeed);
  swap(a.__isset, b.__isset);
}

DiskInfo::DiskInfo(const DiskInfo& other6) {
  total = other6.total;
  free = other6.free;
  readSpeed = other6.readSpeed;
  writeSpeed = other6.writeSpeed;
  __isset = other6.__isset;
}
DiskInfo& DiskInfo::operator=(const DiskInfo& other7) {
  total = other7.total;
  free = other7.free;
  readSpeed = other7.readSpeed;
  writeSpeed = other7.writeSpeed;
  __isset = other7.__isset;
  return *this;
}
void DiskInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DiskInfo(";
  out << "total=" << to_string(total);
  out << ", " << "free=" << to_string(free);
  out << ", " << "readSpeed=" << to_string(readSpeed);
  out << ", " << "writeSpeed=" << to_string(writeSpeed);
  out << ")";
}


NetworkInfo::~NetworkInfo() throw() {
}


void NetworkInfo::__set_downloadSpeed(const double val) {
  this->downloadSpeed = val;
}

void NetworkInfo::__set_uploadSpeed(const double val) {
  this->uploadSpeed = val;
}
std::ostream& operator<<(std::ostream& out, const NetworkInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NetworkInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->downloadSpeed);
          this->__isset.downloadSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->uploadSpeed);
          this->__isset.uploadSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NetworkInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NetworkInfo");

  xfer += oprot->writeFieldBegin("downloadSpeed", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->downloadSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uploadSpeed", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->uploadSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NetworkInfo &a, NetworkInfo &b) {
  using ::std::swap;
  swap(a.downloadSpeed, b.downloadSpeed);
  swap(a.uploadSpeed, b.uploadSpeed);
  swap(a.__isset, b.__isset);
}

NetworkInfo::NetworkInfo(const NetworkInfo& other8) {
  downloadSpeed = other8.downloadSpeed;
  uploadSpeed = other8.uploadSpeed;
  __isset = other8.__isset;
}
NetworkInfo& NetworkInfo::operator=(const NetworkInfo& other9) {
  downloadSpeed = other9.downloadSpeed;
  uploadSpeed = other9.uploadSpeed;
  __isset = other9.__isset;
  return *this;
}
void NetworkInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NetworkInfo(";
  out << "downloadSpeed=" << to_string(downloadSpeed);
  out << ", " << "uploadSpeed=" << to_string(uploadSpeed);
  out << ")";
}


ShellRtn::~ShellRtn() throw() {
}


void ShellRtn::__set_success(const bool val) {
  this->success = val;
}

void ShellRtn::__set_standardOutput(const std::string& val) {
  this->standardOutput = val;
}
std::ostream& operator<<(std::ostream& out, const ShellRtn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShellRtn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->standardOutput);
          this->__isset.standardOutput = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShellRtn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShellRtn");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("standardOutput", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->standardOutput);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShellRtn &a, ShellRtn &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.standardOutput, b.standardOutput);
  swap(a.__isset, b.__isset);
}

ShellRtn::ShellRtn(const ShellRtn& other10) {
  success = other10.success;
  standardOutput = other10.standardOutput;
  __isset = other10.__isset;
}
ShellRtn& ShellRtn::operator=(const ShellRtn& other11) {
  success = other11.success;
  standardOutput = other11.standardOutput;
  __isset = other11.__isset;
  return *this;
}
void ShellRtn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShellRtn(";
  out << "success=" << to_string(success);
  out << ", " << "standardOutput=" << to_string(standardOutput);
  out << ")";
}

}} // namespace
